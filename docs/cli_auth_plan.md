# CLI Authentication Implementation Plan (Browser-Based, Stateless)

## Overview
Implement browser-based CLI authentication for devbox, reusing Lapdev's existing GitHub/GitLab SSO infrastructure and PASETO token system.

**Key Decisions:**
- Using browser-based flow instead of OAuth device flow (RFC 8628) for simplicity and better UX
- **Stateless token-based auth** (no session table) - same pattern as browser sessions
- **REST API** (not HRPC) - standard Bearer token authentication

## Why Browser-Based Over Device Flow?

### Advantages ✅
- **60% less code** - No device codes, user codes, no database tables, no session management
- **Better UX** - No code typing, just click through familiar SSO
- **Faster** - Completes in <30s vs 60s+ with code typing
- **Proven** - Reuses battle-tested `session.rs` PASETO authentication
- **Simpler security** - One token system, same as browser sessions
- **Perfect fit** - Developers run CLI on workstations with browsers
- **Consistent** - Browser sessions don't have revocation either

### Trade-offs ⚠️
- Requires browser (acceptable for devbox use case)
- Can't auth from different device (e.g., phone → headless server)
- No session revocation (same limitation as browser sessions)
- No session management UI (no device listing)

### Decision
Browser-based stateless is ideal for devbox because:
1. Target users: Developers on local workstations (browser always available)
2. Use case: Interactive development workflow
3. Timeline: Faster implementation (~1 week vs 2-3 weeks)
4. Maintenance: Minimal code to maintain long-term
5. **Consistency**: Same security model as browser sessions

## Goals
- Enable simple CLI authentication by opening browser for SSO
- Reuse existing `oauth_connection` table, SSO flow, and PASETO tokens
- Support secure token storage across platforms (macOS/Linux/Windows)
- Maintain RBAC enforcement and security boundaries
- **Zero new database tables** - pure token-based authentication
- Minimize new code by leveraging proven `session.rs` authentication

## Architecture

### Flow Overview
```
1. CLI generates random session_id (UUID)
2. CLI opens browser to /auth/cli?session_id=xxx&device_name=My+Laptop
3. User completes existing SSO flow (GitHub/GitLab) - reuses session.rs
4. After OAuth success, API:
   - Creates PASETO token with claims: user_id, org_id, device_name, session_type="cli"
   - Token expiry: 30 days (same as browser sessions)
   - Stores in pending_cli_auth map: session_id → token (in-memory, 5-min TTL)
   - Shows success page: "CLI authenticated successfully"
5. CLI polls GET /api/v1/auth/cli/token?session_id=xxx every 2 seconds
6. API returns token when available, else 404
7. CLI stores token in OS keychain
8. Future requests: CLI sends Authorization: Bearer <paseto_token>
9. API validates by decrypting PASETO + loading user (no session table lookup)
```

**Key simplification:** No database tables, no session tracking, no revocation. Pure stateless tokens like browser sessions.

### Data Model

#### PASETO Token Claims
```rust
{
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "organization_id": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    "session_type": "cli",
    "device_name": "My MacBook",
    "exp": "2025-11-07T12:00:00Z"  // 30 days from creation
}
```

#### In-Memory State (Only During Login)

**`PendingCliAuth`** (in CoreState, not persisted)
```rust
// In crates/api/src/state.rs
pub struct PendingCliAuth {
    pub token: String,  // PASETO token
    pub expires_at: DateTime<Utc>,  // 5 minutes from creation
}

// In CoreState:
pub pending_cli_auth: Arc<RwLock<HashMap<Uuid, PendingCliAuth>>>,
```

Background job cleans up expired entries every minute.

#### Existing Tables (No Changes)
- `oauth_connection`: Stores GitHub/GitLab OAuth tokens (reused as-is)
- `users`: User identity (reused as-is)
- `organizations`: Org membership (reused as-is)
- **No new tables needed!**

## Implementation Components

### 1. API Endpoints (REST, not HRPC)

**Why REST instead of HRPC?**
- HRPC client uses `gloo_net` (browser/WASM-only, doesn't work in native CLI)
- Bearer token auth is HTTP standard (vs cookie-based for HRPC)
- Browser redirects and polling don't fit RPC pattern
- `reqwest` is simpler than building native HRPC client

#### `GET /auth/cli` (Browser Entry Point)
**File:** `crates/api/src/cli_auth.rs`

**Query Parameters:**
- `session_id`: UUID generated by CLI
- `device_name`: User-friendly device name (e.g., "My MacBook")

**Implementation:**
1. Store `session_id` and `device_name` in temporary PASETO cookie/state
2. Redirect to existing `/api/private/session/new` with provider selection
3. After SSO complete, extract session_id from state

**This reuses the entire existing SSO flow!**

#### Modified `session_authorize` (in `crates/api/src/session.rs`)
**Add CLI handling after OAuth success:**
```rust
// After successful OAuth and user creation/update...

// Check if this is a CLI auth request
if let Some((cli_session_id, device_name)) = extract_cli_session_from_state(&cookie) {
    // Create PASETO token for CLI (same format as browser, but different claims)
    let mut claims = Claims::new_expires_in(&Duration::from_secs(86400 * 30))?;
    claims.add_additional("user_id", user.id.to_string())?;
    claims.add_additional("organization_id", user.current_organization.to_string())?;
    claims.add_additional("session_type", "cli")?;
    claims.add_additional("device_name", device_name)?;
    let token = pasetors::local::encrypt(&state.auth_token_key, &claims, None, None)?;

    // Store in pending_cli_auth map (5-min TTL)
    state.pending_cli_auth.write().await.insert(
        cli_session_id,
        PendingCliAuth {
            token: token.clone(),
            expires_at: Utc::now() + Duration::seconds(300),
        }
    );

    // Redirect to success page
    return Ok(Redirect::temporary("/cli/success").into_response());
}

// Otherwise, continue with normal browser cookie flow...
```

#### `GET /api/v1/auth/cli/token` (Token Polling)
**File:** `crates/api/src/cli_auth.rs`

**Query Parameters:**
- `session_id`: UUID from CLI

**Response (Success):**
```rust
struct CliTokenResponse {
    token: String,  // PASETO token
    expires_in: u32,  // 2592000 (30 days)
}
```

**Response (Pending):**
- HTTP 404

**Implementation:**
```rust
pub async fn get_cli_token(
    Query(params): Query<CliTokenQuery>,
    State(state): State<Arc<CoreState>>,
) -> Result<Json<CliTokenResponse>, ApiError> {
    let pending = state.pending_cli_auth.read().await;

    if let Some(auth) = pending.get(&params.session_id) {
        if auth.expires_at > Utc::now() {
            // Remove from pending (single use)
            let token = auth.token.clone();
            drop(pending);
            state.pending_cli_auth.write().await.remove(&params.session_id);

            return Ok(Json(CliTokenResponse {
                token,
                expires_in: 2592000,
            }));
        }
    }

    Err(ApiError::NotFound)
}
```

#### `GET /cli/success` (Success Page)
**File:** `crates/dashboard/src/cli_success.rs` (Leptos component)

Simple HTML page:
```rust
#[component]
pub fn CliSuccess() -> impl IntoView {
    view! {
        <div class="flex flex-col items-center justify-center min-h-screen">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-green-600">"✓ CLI Authenticated Successfully"</h1>
                <p class="mt-4 text-gray-600">"You can close this window and return to your terminal."</p>
                <p class="mt-2 text-sm text-gray-500">"This window will close automatically in 3 seconds..."</p>
            </div>
        </div>
    }
}
```

#### `GET /api/v1/devbox/whoami` (Current User Info)
**File:** `crates/api/src/devbox.rs`

**Authentication:** `Authorization: Bearer <paseto_token>` header required

**Response:**
```rust
struct WhoamiResponse {
    user_id: Uuid,
    email: String,
    name: Option<String>,
    organization_id: Uuid,
    device_name: String,
    authenticated_at: String,  // From token exp claim
    expires_at: String,
}
```

**Implementation:**
```rust
pub async fn devbox_whoami(
    State(state): State<Arc<CoreState>>,
    TypedHeader(auth): TypedHeader<headers::Authorization<headers::authorization::Bearer>>,
) -> Result<Json<WhoamiResponse>, ApiError> {
    let ctx = state.authenticate_bearer(&auth).await?;

    Ok(Json(WhoamiResponse {
        user_id: ctx.user.id,
        email: ctx.user.email,
        name: ctx.user.name,
        organization_id: ctx.organization_id,
        device_name: ctx.device_name,
        authenticated_at: ctx.token_claims.get_claim("iat")...,
        expires_at: ctx.token_claims.get_claim("exp")...,
    }))
}
```

### 2. Authentication Helper (Bearer Token Validation)

**File:** `crates/api/src/devbox_auth.rs` (new file)

```rust
use anyhow::Result;
use axum_extra::headers::{self, authorization::Bearer};
use lapdev_db_entities::user;
use lapdev_rpc::error::ApiError;
use uuid::Uuid;

use crate::state::CoreState;

pub struct DevboxContext {
    pub user: user::Model,
    pub organization_id: Uuid,
    pub device_name: String,
    pub token_claims: pasetors::claims::Claims,
}

impl CoreState {
    /// Authenticate CLI request using Bearer token (PASETO)
    /// Same pattern as browser session authentication - stateless!
    pub async fn authenticate_bearer(
        &self,
        auth_header: &headers::Authorization<Bearer>,
    ) -> Result<DevboxContext, ApiError> {
        let token = auth_header.token();

        // 1. Decrypt and validate PASETO token (same as browser cookies)
        let validated = pasetors::local::decrypt(
            &self.auth_token_key,
            token,
            &pasetors::claims::ClaimsValidationRules::new(),
            None,
            None,
        )
        .map_err(|_| ApiError::Unauthenticated)?;

        let claims = validated
            .payload_claims()
            .ok_or(ApiError::Unauthenticated)?;

        // 2. Extract and verify claims
        let user_id: Uuid = claims
            .get_claim("user_id")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .ok_or(ApiError::Unauthenticated)?;

        let organization_id: Uuid = claims
            .get_claim("organization_id")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .ok_or(ApiError::Unauthenticated)?;

        let session_type: String = claims
            .get_claim("session_type")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default();

        if session_type != "cli" {
            return Err(ApiError::Unauthenticated);
        }

        let device_name: String = claims
            .get_claim("device_name")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .ok_or(ApiError::Unauthenticated)?;

        // 3. Load user (same as browser sessions - no session table lookup!)
        let user = user::Entity::find_by_id(user_id)
            .filter(user::Column::DeletedAt.is_null())
            .one(&self.db.conn)
            .await
            .map_err(|e| ApiError::InternalError(e.to_string()))?
            .ok_or(ApiError::Unauthenticated)?;

        Ok(DevboxContext {
            user,
            organization_id,
            device_name,
            token_claims: claims,
        })
    }
}
```

### 3. CLI Crate Setup

#### Create New Crate: `crates/cli`
```bash
# From workspace root
mkdir -p crates/cli/src/devbox/commands
mkdir -p crates/cli/src/api
```

**Directory Structure:**
```
crates/cli/
├── Cargo.toml
└── src/
    ├── main.rs          # Entry point, top-level Clap setup
    ├── devbox/
    │   ├── mod.rs       # Devbox subcommand module
    │   ├── auth.rs      # Token storage (keychain)
    │   └── commands/
    │       ├── mod.rs
    │       ├── login.rs     # Browser flow login
    │       ├── logout.rs    # Delete token from keychain
    │       └── whoami.rs    # Session info display
    └── api/
        ├── mod.rs
        └── client.rs    # HTTP client for Lapdev API (reqwest)
```

**`crates/cli/Cargo.toml`:**
```toml
[package]
name = "lapdev-cli"
version.workspace = true
authors.workspace = true
edition.workspace = true

[dependencies]
# Workspace dependencies
clap.workspace = true
anyhow.workspace = true
thiserror.workspace = true
uuid.workspace = true
chrono.workspace = true
serde.workspace = true
serde_json.workspace = true
reqwest.workspace = true
tokio.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true

# CLI-specific dependencies
keyring = "2.0"
webbrowser = "0.8"
colored = "2.0"
```

**Add to root `Cargo.toml` workspace members:**
```toml
[workspace]
members = [
  # ... existing members ...
  "crates/cli",
]
```

**Add binary definition to root `Cargo.toml`:**
```toml
[[bin]]
name = "lapdev"
path = "crates/cli/src/main.rs"
```

**Build and Run:**
```bash
# Development
cargo build --bin lapdev
cargo run --bin lapdev -- devbox --help

# Install locally for testing
cargo install --path crates/cli --bin lapdev

# Now you can run:
lapdev devbox login
lapdev devbox whoami
lapdev devbox logout
```

**Basic CLI Structure (`src/main.rs`):**
```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "lapdev")]
#[command(about = "Lapdev CLI - Self-Hosted Remote Dev Environment", long_about = None)]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Enable verbose logging
    #[arg(short, long, global = true)]
    verbose: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Devbox development environment commands
    Devbox {
        #[command(subcommand)]
        action: devbox::DevboxCommand,
    },
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Setup logging
    if cli.verbose {
        tracing_subscriber::fmt()
            .with_max_level(tracing::Level::DEBUG)
            .init();
    }

    match cli.command {
        Commands::Devbox { action } => {
            devbox::handle_command(action).await?;
        }
    }

    Ok(())
}

mod devbox;
mod api;
```

**Devbox Module (`src/devbox/mod.rs`):**
```rust
use clap::Subcommand;

#[derive(Subcommand)]
pub enum DevboxCommand {
    /// Authenticate with Lapdev
    Login {
        /// Device name (defaults to hostname)
        #[arg(long)]
        device_name: Option<String>,

        /// API server URL
        #[arg(long, env = "LAPDEV_API_URL", default_value = "https://lapdev.example.com")]
        api_url: String,
    },

    /// Sign out (deletes token from keychain)
    Logout {
        /// API server URL
        #[arg(long, env = "LAPDEV_API_URL", default_value = "https://lapdev.example.com")]
        api_url: String,
    },

    /// Show current session info
    Whoami {
        /// API server URL
        #[arg(long, env = "LAPDEV_API_URL", default_value = "https://lapdev.example.com")]
        api_url: String,
    },

    // Future commands:
    // Connect { environment: String },
    // Disconnect,
    // Status,
    // Intercept { ... },
}

pub async fn handle_command(command: DevboxCommand) -> anyhow::Result<()> {
    match command {
        DevboxCommand::Login { device_name, api_url } => {
            commands::login::execute(&api_url, device_name).await?;
        }
        DevboxCommand::Logout { api_url } => {
            commands::logout::execute(&api_url).await?;
        }
        DevboxCommand::Whoami { api_url } => {
            commands::whoami::execute(&api_url).await?;
        }
    }

    Ok(())
}

pub mod auth;
mod commands;
```

### 4. CLI Authentication (`crates/cli/src/devbox/auth.rs`)

#### Token Storage Strategy
```rust
// Use OS Keychain:
// - macOS: Keychain
// - Linux: Secret Service (GNOME Keyring / KWallet)
// - Windows: Credential Manager

struct TokenStorage {
    service: String,  // "com.lapdev.cli"
    account: String,  // API URL (e.g., "https://lapdev.example.com")
}

pub fn store_token(api_url: &str, token: &str) -> Result<()> {
    let entry = keyring::Entry::new("com.lapdev.cli", api_url)?;
    entry.set_password(token)?;
    Ok(())
}

pub fn get_token(api_url: &str) -> Result<String> {
    let entry = keyring::Entry::new("com.lapdev.cli", api_url)?;
    let token = entry.get_password()?;
    Ok(token)
}

pub fn delete_token(api_url: &str) -> Result<()> {
    let entry = keyring::Entry::new("com.lapdev.cli", api_url)?;
    entry.delete_password()?;
    Ok(())
}
```

#### `lapdev devbox login`
```bash
lapdev devbox login [--device-name "My MacBook"] [--api-url https://lapdev.example.com]
```

**Flow:**
1. Generate random `session_id` (UUID)
2. Get device name (from flag, environment, or hostname)
3. Build URL: `https://lapdev.example.com/auth/cli?session_id={uuid}&device_name={name}`
4. Display message:
   ```
   Opening browser for authentication...
   If browser doesn't open, visit: https://lapdev.example.com/auth/cli?session_id=...
   Waiting for authentication...
   ```
5. Open browser using `webbrowser` crate
6. Poll `GET /api/v1/auth/cli/token?session_id={uuid}` every 2 seconds (max 5 minutes)
7. On success (token received):
   - Store PASETO token in keychain (service: `com.lapdev.cli`, account: API URL)
   - Fetch user info from API (using token) and display:
     ```
     ✓ Authenticated as alice@example.com
     Device: My MacBook
     Expires: 2025-11-07 (30 days)
     ```
8. On timeout/error: Display helpful error message

#### `lapdev devbox logout`
**Flow (Client-side only - no API call needed!):**
1. Read token from keychain (to verify it exists)
2. Delete token from keychain
3. Display: `✓ Logged out successfully`

**Note:** No server-side revocation since browser sessions don't have it either.

#### `lapdev devbox whoami`
**Flow:**
1. Read token from keychain
2. Call API: `GET /api/v1/devbox/whoami` with `Authorization: Bearer <token>`
3. Display user info:
   ```
   User: alice@example.com
   Organization: acme-corp
   Device: My MacBook
   Authenticated: 2025-10-07 12:00:00 UTC
   Expires: 2025-11-07 12:00:00 UTC (29 days remaining)
   ```

### 5. CLI API Client (`crates/cli/src/api/client.rs`)

```rust
use anyhow::{Context, Result};
use reqwest::{Client, StatusCode};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

pub struct LapdevClient {
    client: Client,
    base_url: String,
    token: Option<String>,
}

impl LapdevClient {
    pub fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
            token: None,
        }
    }

    pub fn with_token(mut self, token: String) -> Self {
        self.token = Some(token);
        self
    }

    /// Poll for CLI token after browser auth
    pub async fn poll_cli_token(&self, session_id: Uuid) -> Result<Option<CliTokenResponse>> {
        let url = format!("{}/api/v1/auth/cli/token?session_id={}", self.base_url, session_id);

        let resp = self.client.get(&url).send().await?;

        match resp.status() {
            StatusCode::OK => {
                let token_resp = resp.json().await?;
                Ok(Some(token_resp))
            }
            StatusCode::NOT_FOUND => Ok(None),
            status => Err(anyhow::anyhow!("Unexpected status: {}", status)),
        }
    }

    /// Get current user info
    pub async fn whoami(&self) -> Result<WhoamiResponse> {
        let token = self.token.as_ref().context("Not authenticated")?;

        let resp = self.client
            .get(format!("{}/api/v1/devbox/whoami", self.base_url))
            .header("Authorization", format!("Bearer {}", token))
            .send()
            .await?
            .error_for_status()?
            .json()
            .await?;

        Ok(resp)
    }
}

#[derive(Debug, Deserialize)]
pub struct CliTokenResponse {
    pub token: String,
    pub expires_in: u32,
}

#[derive(Debug, Deserialize)]
pub struct WhoamiResponse {
    pub user_id: Uuid,
    pub email: String,
    pub name: Option<String>,
    pub organization_id: Uuid,
    pub device_name: String,
    pub authenticated_at: String,
    pub expires_at: String,
}
```

### 6. Background Jobs

#### Pending CLI Auth Cleanup
**File:** `crates/api/src/background_jobs.rs` (or similar)

```rust
// Run every minute - clean up expired pending auths
async fn cleanup_pending_cli_auth(state: &CoreState) {
    let now = Utc::now();
    let mut pending = state.pending_cli_auth.write().await;
    pending.retain(|_, auth| auth.expires_at > now);
}
```

## Testing Strategy

### Unit Tests
- [ ] PASETO token creation with CLI claims
- [ ] Token validation (decrypt + extract claims)
- [ ] Keychain storage/retrieval

### Integration Tests
- [ ] Complete browser auth flow (browser → token → CLI)
- [ ] Token polling (404 → success)
- [ ] Expired pending auth cleanup
- [ ] Bearer token authentication

### CLI Tests
- [ ] Keychain storage/retrieval (macOS/Linux/Windows)
- [ ] Browser opening
- [ ] Polling retry logic
- [ ] Error message formatting

### Security Tests
- [ ] Expired token rejection
- [ ] Invalid session_type rejection
- [ ] Deleted user detection
- [ ] Rate limiting on token endpoint

## Implementation Checklist

### Phase 1: Backend API (1-2 days)
- [ ] Add `PendingCliAuth` struct and map to `CoreState` in `crates/api/src/state.rs`
- [ ] Create `crates/api/src/cli_auth.rs` module
- [ ] Implement `GET /auth/cli` entry point (redirects to SSO with CLI state)
- [ ] Modify `session_authorize` in `session.rs` to detect CLI auth and create PASETO token with CLI claims
- [ ] Implement `GET /api/v1/auth/cli/token` polling endpoint
- [ ] Create `crates/api/src/devbox_auth.rs` with Bearer token authentication
- [ ] Implement `GET /api/v1/devbox/whoami` endpoint
- [ ] Add background cleanup job for pending CLI auth map (1-minute interval)
- [ ] Add routes to API router

### Phase 2: Web UI (0.5-1 day)
**Note:** Frontend is Leptos-based (`crates/dashboard`)
- [ ] Create `/cli/success` page component (simple success message)
- [ ] Test SSO flow still works (no changes needed, just verify)

### Phase 3: CLI (2-3 days)
- [ ] Create new `crates/cli` directory and module structure
- [ ] Add `crates/cli` to workspace members in root `Cargo.toml`
- [ ] Add binary definition `[[bin]]` for `lapdev` in root `Cargo.toml`
- [ ] Create `crates/cli/Cargo.toml` with workspace dependencies
- [ ] Set up `main.rs` with top-level Clap structure + `devbox` subcommand
- [ ] Create devbox module (`src/devbox/mod.rs` with command routing)
- [ ] Implement token storage in `devbox/auth.rs` (keychain)
- [ ] Implement API client in `src/api/client.rs` (Bearer token auth with reqwest)
- [ ] Implement `devbox login` command:
  - [ ] Generate session_id
  - [ ] Open browser to `/auth/cli?session_id=xxx&device_name=xxx`
  - [ ] Poll `/api/v1/auth/cli/token` endpoint
  - [ ] Store token in keychain
- [ ] Implement `devbox logout` command (delete from keychain)
- [ ] Implement `devbox whoami` command (call `/api/v1/devbox/whoami`)
- [ ] Add browser opening logic (`webbrowser` crate)
- [ ] Add polling with backoff (2s intervals, 5-min timeout)
- [ ] Error handling and user-friendly messages
- [ ] Test: `cargo run --bin lapdev -- devbox --help`
- [ ] Test: `cargo install --path crates/cli --bin lapdev && lapdev devbox login`

### Phase 4: Testing (1 day)
- [ ] End-to-end browser auth flow test
- [ ] CLI keychain tests (macOS/Linux/Windows)
- [ ] Token polling timeout handling
- [ ] PASETO token validation tests
- [ ] Security audit (token storage, expiry)

### Phase 5: Documentation (0.5 day)
- [ ] User guide for CLI authentication
- [ ] CLI command reference (`lapdev devbox --help` output)
- [ ] Security best practices (token storage, expiry)
- [ ] Troubleshooting guide (browser doesn't open, timeout, keychain issues)

## Open Questions

1. **Multi-Org Support**: How should CLI handle users in multiple orgs?
   - **Recommendation**: Use current_organization from user, allow switching via `lapdev devbox org switch` (defer to Phase 2)

2. **Session Refresh**: Should we support token refresh, or require re-authentication?
   - **Recommendation**: No refresh (simpler security model, 30-day tokens sufficient, same as browser)

3. **Rate Limiting**: What limits on browser auth and token polling?
   - **Recommendation**: Reuse existing SSO rate limits; 1 poll per 2 seconds per session_id

4. **Fallback for Headless**: What if user can't open browser?
   - **Recommendation**: Phase 1 requires browser; Phase 2 can add manual URL copy option

## Dependencies

### Rust Crates

**Add to root `Cargo.toml` workspace dependencies:**
```toml
[workspace.dependencies]
# ... existing dependencies ...
# New dependencies for CLI:
keyring = "2.0"
webbrowser = "0.8"
colored = "2.0"
```

**In `crates/api/Cargo.toml`:**
- No new dependencies! Reuses existing: pasetors, chrono, uuid, axum

**`crates/cli/Cargo.toml`** (see "CLI Crate Setup" section for complete file)
- Uses workspace dependencies: clap, anyhow, thiserror, uuid, chrono, serde, serde_json, reqwest, tokio, tracing, tracing-subscriber
- New dependencies: keyring, webbrowser, colored

### External Services
- GitHub OAuth (existing)
- GitLab OAuth (existing)
- No new external dependencies

## Rollout Plan

### Days 1-2: Backend API
- Add `PendingCliAuth` to `CoreState`
- Implement `cli_auth.rs` with browser flow endpoints
- Modify `session_authorize` for CLI detection
- Add Bearer token authentication helper
- Add `whoami` REST endpoint
- Background cleanup job

### Day 3: Web UI
- `/cli/success` page (Leptos component)
- Test existing SSO flow still works

### Days 4-6: CLI Implementation
- Set up `crates/cli` project structure
- Implement token storage (keychain)
- Implement `lapdev devbox login` (browser + polling)
- Implement `lapdev devbox logout/whoami`
- Error handling and UX polish

### Day 7: Testing & Documentation
- End-to-end flow testing
- Multi-platform keychain testing
- Security audit
- User documentation

**Total: ~1 week** (vs 2-3 weeks for session-table approach, 3-4 weeks for OAuth device flow)

## Success Criteria

1. ✅ User can authenticate CLI by clicking through browser SSO (no code typing!)
2. ✅ PASETO tokens are securely stored in OS keychain
3. ✅ Sessions expire after 30 days (PASETO expiry)
4. ✅ Browser flow completes in <30 seconds
5. ✅ Multi-platform support (macOS, Linux, Windows)
6. ✅ Clear error messages for all failure modes
7. ✅ Reuses battle-tested session.rs authentication code
8. ✅ **Minimal new code** (~70% less than device flow, ~40% less than session-table approach)
9. ✅ **Zero new database tables**
10. ✅ **Consistent with browser session security model**
